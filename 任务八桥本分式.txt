回溯或分支界限实现1-9填入合理并数字不重复
采用回溯法逐步调整探求；

设置a数组，式中每一 口 位置用一个数组元素来表示，如下：


a(1)/a(2)a(3) + a(4)/a(5)a(6) = a(7)/a(8)a(9)


为避免解的重复，设a(1)< a(4)，同时记式中的3个分母分别为：


m1 = a(2)a(3) = a(2)*10+a(3)；
m2 = a(5)a(6) = a(5)*10+a(6)；
m3 = a(8)a(9) = a(8)*10+a(9)；


可见，问题的解空间是9位整数组，其约束条件是9位数中没有相同数字且必须满足分式的要求；

所求分数等式等价于整数等式 a(1)*m2*m3 + a(4)*m1*m3 = a(7)*m1*m2 成立，这一转化可以把分数的测试转化为整数测试；

为判断数字是否重复，设置中间变量g：先赋值g=1；若出现某两数字相同（即a(i)=a(k)）或 a(1)>a(4)，则赋值g=0（重复标记）；

先从a（1）=1开始，逐步a（i）（1<=i<=9）赋值，每一个a（i）赋值从1开始递增至9，直至a（9）赋值，判断：


若i=9，g=1，a(1)*m2*m3 + a(4)*m1*m3 = a(7)*m1*m2同时满足，则为一组解，用n统计解的个数后格式输出这组解；
若i<9且g=1，表明还不到9个数字，则下一个a（i）从1开始赋值继续；
若a（9）=9，则返回前面一个数组元素a（8）增1赋值（此时，a(9)又从1开始）再试；
若a（8）=9，则返回前一个数组元素a（7）增1赋值再试，以此类推，直到a（1）=9时，以无法返回，意味着已全部试毕，求解结束；
————————————————
版权声明：本文为CSDN博主「double_main」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/double_main/article/details/54140890

#include<stdio.h>
int main()
{
   int g,i,k,s,a[10];
   long m1,m2,m3;
   printf("桥本分数式有:\n");
   i=1;
   a[1]=1;
   s=0;
   while(1)
   {
      g=1;
      for(k=i-1;k>=1;k--)
         if(a[i]==a[k])
         {
            g=0;           /*两数相同,标记g=0*/
            break;
         }
      if(i==9 && g==1 && a[1]<a[4])
      {
         m1=a[2]*10+a[3];
         m2=a[5]*10+a[6];
         m3=a[8]*10+a[9];
         if(a[1]*m2*m3+a[4]*m1*m2==a[7]*m1*m2)
         {
            s++;
            printf("(%2d)",s);
            printf("%d/%d+%d/",a[1],m1,a[4]);
            printf("%ld=%d/%ld  ",m2,a[7],m3);
            if(s%2==0)
               printf("\n");
         }
      }
      if(i<9 && g==1)
      {
         i++;
         a[i]=1;
         continue;          /*不到9个数,往后继续*/
      }
      while(a[i]==9 && i>1)
         i--;               /*往前回溯*/
      if(a[i]==9 && i==1)
         break;
      else
         a[i]++;            /*至第1个数为9结束*/
   }
   printf("共以上%d个解\n",s);
}
